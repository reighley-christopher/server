fs = require('fs');
http = require('http');
Promise = require('promise');
child_process = require('child_process');


function http_promise(host, path, port)
  {
  return new Promise
    (function(resolve, reject){
    http.get({hostname: host, path: path, port: port}, 
      function(rs){
        var doc = []; rs.on('data', function(d){doc.push(d)}); rs.on('end', function(){var ret = Buffer.concat(doc); resolve(JSON.parse(ret));}) 
      });
    });
  }

/*
to impliment behold : 
thde behold function will create a new beholder object.
beholder has two members, a function by which takes a single promise and returns a beholder.
a function thow which takes a function and returns a promise.

the result of thow will be a promise which fulfills once all of the "by" promises have fulfilled, with a value computed by the parameter function. 

*/

var Beholder = function()
  {
  var promise_list = [];

  this.by = function( prom ) 
    {
    promise_list.push(prom);
    return this;
    };

  this.thow = function( func ) 
    {
    return new Promise(function(resolve, reject) 
      {
      var i;
      var count = 0;
      var params = [];
      function indexed_onFulfilled(i)
        {
        return function(value)
          {
          params[i] = value;
          count = count+1;
          if(count == promise_list.length) 
            {
            resolve(func.apply(null, params))
            }
          }
        }
      function indexed_onRejected(i)
        {
          return function(reason)
            {
            /*TODO handle error here*/
            }
        }
      for(i in promise_list) 
        {
        promise_list[i].then(indexed_onFulfilled(i), indexed_onRejected(i))
        }
      }) 
    };
  }

function behold() { return new Beholder }

var catalog = http_promise('localhost', '/run/catalog', 80).then( http_promise('localhost', '/riak/buckets/processes/keys/'+process.argv[3], 80) )
var parameters = http_promise('localhost', '/riak/buckets/processes/keys/'+process.argv[3])

function cmd_string(data, catalog)
  {
  var entry = catalog[data.name].schema;
  var cmd = "components/" + data.name;
  var i;
  if(entry.output == 'amqp') { cmd = cmd + " " + process.argv[2]; }
  for( i in entry.parameters )
    {
    cmd = cmd + " '" + data.parameters[entry.parameters[i]] + "'"
    }
  return cmd;
  }

behold().by( catalog ).by( parameters ).thow( 
  function (catalog, parameters)
  {
  var index = {};
  var i = 0;
  var commands = "";
  var z;
  console.log(JSON.stringify(parameters));
  console.log(JSON.stringify(catalog));
  
  for(z in parameters.inputs) 
    {
    index[z] = i;
    commands = commands + "E " + i + " " + 
      cmd_string(parameters.inputs[z].task, catalog) + "\n";
    i = i + 1;
    }

  for(z in parameters.processes)
    {
    index[z] = i;
    commands = commands + "E " + i + " " +
      cmd_string(parameters.processes[z].task, catalog) + "\n";
    i = i + 1;
    }

  for(z in parameters.outputs)
    {
    index[z] = i;
    commands = commands + "E " + i + " " +
      cmd_string(parameters.outputs[z].task, catalog) + "\n";
    i = i + 1;
    }

  for(z in parameters.connect)
    {
      commands = commands + "P " + index[parameters.connect[z].from] +
      " " + index[parameters.connect[z].to] + "\n";
    }
  commands = commands + "X\n";
  console.log(commands);
  proc = child_process.spawn('bin/pipefitter');
  console.log(proc);
  proc.stdin.write(commands);
  proc.stdout.on('data', function(x){console.log(x.toString())});
  }
);


